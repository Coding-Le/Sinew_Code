一打开界面，你就可以看到对应的提示信息，数字1 代表实现insert_file 的功能，
数字2 代表实现输出目录的功能，数字3 代表实现查找的功能，如果想要退出，
输入0
我们输入了1，显示如下提示信息，要求输入想要实现序列化的文件的名称，这
个时候用户可以直接copy 屏幕上的nobench_data.json（默认文件，大约10w 条
记录），或者用户可以自己利用nobench 生成一些记录，但是需要给出文件的路
径+文件名称，不然fopen 可能打不开。
用户输入完nobench_data.json 之后，按下回车，程序就开始进行序列化了，序列
化完成之后会自动进行反序列化，整个过程大约耗时1min 左右，主要时间花费
在文件读写上，输出如下结果，序列化的文件保存在insert_to_binary 文件夹中，
没有序列化但是转变成为论文中要求的格式的文件保存在insert to pdf form 文件
夹中，从insert_to_binary 文件反序列化得到的文件保存在insert_back_to_json 文
件夹中，可以在相应目录下看到。
输入数字编号2，就可以实现输出目录的功能，我们同样可以在catalog_for_user
文件夹中查看输出的目录。
输入数字3，我们就可以进行查找，屏幕会给出如下提示信息：
用户必须要输入find A = B 这样的命令才能够进行查询，A 是属性名，B 是属性
的值：
比如输入find bool = true
一旦按下回车，屏幕上就会不断出现相对应的json 记录，像find bool = true 这样
的查询大约能够查询到2w 条记录，整个过程大约花费5 秒，这是因为全表扫描
可以很好的减少文件读写的时间，但是需要每一条记录都进行比较，这大大降低
了执行效率。同样的，你可以在find_result 文件夹中查看搜索到的结果，见下图：
接下来你可以重新输入1 对另外一个文件进行序列化，循环往复，直到接收到0
的退出信号或者用户操作不当造成的错误异常，程序才会退出。